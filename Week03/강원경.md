# TCP
- 기존의 통신 프로토콜에 <U>전송, 송신, 통신</U>을 <u>제어</u>하는 연결 지향의 신뢰성 있는 전송 프로토콜
- 프로세스간의 통신
- 데이터 단위: 세그먼트
<br/><br>

## 프로세스간 통신
### 호스트-대-호스트 vs 프로세스-대-프로세스 통신의 차이
|제목|사용 프로토콜|구분하는 방법(주소)|
|------|:---:|:---:|
|호스트-대-호스트|IP|IP 주소|
|프로세스-대-프로세스|TCP|포트 번호|
<br>

클라이언트-서버 통신에서 클라이언트는 통신 간 임시 포트번호 (1023번보다 큰 번호)를 사용하지만  
서버는 이 방식으로 정의하는 경우 다른 클라이언트들이 **통신하려는 포트번호를 알아내는데  
추가적인 시간이 필요하므로 오버헤드 최소화를 위해** 일반적으로 잘 알려진 포트번호를 사용한다.  
포트번호의 범위는 0 ~ 65535 이다.

|포트 번호 분류|포트번호 범위|설명|
|------|:---:|:---:|
|잘 알려진 포트 번호|0 ~ 1023|서버를 위해 예약된 포트번호|
|역할이 지정된 포트 번호|1024 ~ 49151|예약되지는 않았으나<br>일반적으로 약속된 역할이 있는 포트번호|
|빈 포트 번호|49152 ~ 65535|클라이언트를 위한 임시 포트 번호|
<br>

### TCP에서 잘 알려진 포트 번호

|포트 번호|응용 프로토콜|설명|
|:---:|:---:|:---|
|7|Echo|수신된 메시지를 송신 측에 에코함|
|9|Discard|수신된 메시지를 버림|
|11|Users|활성화된 사용자|
|13|Daytime|현재 날짜와 시간을 반환|
|20|FTP,Data|파일 전송 프로토콜(데이터 전송)에서 사용|
|21|FTP,Control|파일 전송 프로토콜(제어신호 전송)에서 사용|
|23|Telnet|터미널 네트워크|
|25|SMTP|메일 전송 프로토콜에서 사용|
|80|HTTP|하이퍼텍스트 전송 프로토콜|
<br>

## TCP의 여러 서비스
1. 스트림 전달 서비스
스트림이란 바이트 단위의 일정한 크기의 세그먼트들을 인터넷 상에서 TCP에 의해  
두 개의 프로세스 사이에 연결된 가상의 전송 통로를 통하여 데이터를 전송하는 것을 의미한다.
2. 전이중 통신
데이터를 동시에 양방향으로 전송할 수 있는 전이중 서비스를 제공한다.
3. 연결 지향 서비스
두 프로세스간 통신이 이루어지는 경우 먼저 두 프로세스간에 가상의 연결이 설정된다. 데이터 전송이 종료되면 이 연결도 해제된다.  
<br><br>

## TCP 헤더
<img src="https://t1.daumcdn.net/cfile/tistory/994511465AF2DC262D"> <br>
[TCP 헤더의 구조]
- 발신지 포트 주소 : 발신측이 클라이언트라면 임의로 지정된 포트번호가, 서버라면 잘 알려진 포트번호가 기록되어있다.
- 목적지 포트 주소 : 수신측이 서버라면 잘 알려진 포트번호를 기록하고, 클라이언트라면 직전에 수신된 패킷의 발신 포트번호를 복사해온다.
- 순서번호 (Sequence number): 세그먼트에 포함된 첫 번째 바이트에 부여된 번호를 나타낸다. TCP는 신뢰성 있는 통신을 보장하는 프로토콜이므로 <br>이를 보장하기 위해 각 바이트마다 번호를 부여한다.
- 확인 응답 번호 (Acknowledgement number): 상대편 노드로부터 수신하고자 하는 바이트의 번호를 정의한다.
- 헤더 번호 : TCP 헤더의 길이를 4바이트 단위로 그 값을 나타낸다. 즉, 값이 5인경우 5×4=20 바이트 가 되는 것이다. <br> 이 값은 5~15사이의 값이 된다.
- 예약 : 현재는 아무 역할이 없는 여유공간이다.
- 제어 플래그  
  1. URG : 긴급 포인터(Urgent Pointer) 값이 유효함을 의미
  2. ACK : 확인 응답 번호(Acknowledgement number)의 값이 유효한 값임을 의미
  3. PSH : 데이터를 푸시함.
  4. RST : 연결을 재정의함
  5. SYN : 연결 설정을 위해 순서를 동기화할 때 사용
  6. FIN : 연결이 종료되었음을 의미
- 윈도우 크기 (Window size): 상대편에서 유지되어야 하는 바이트 단위의 윈도우 크기를 정의한다. <br>즉, 송신측에서 최대로 보낼 수 있는 바이트 값이다. (0~65535 범위)
- 검사함(Checksum): 통신간 송/수신된 데이터 중 잘못 수신된 데이터가 없는지 여부를 확인하기 위해 사용되는 의사헤더 (가상의 헤더)이다.
- 긴급 포인터: 긴급 플래그(URG)가 1인 경우 세그먼트가 긴급데이터를 포함하고 있음을 나타낸다.
- 옵션 (Option): 최대 40바이트까지 존재할 수 있으며, 목적지에 부가 정보를 전달하거나 옵션의 정렬을 맞추기 위해 사용한다.  
<br><br>

## TCP 연결
TCP는 양방향 통신이 가능한 전이중 모드로 데이터를 전송하고 신뢰성 있는 통신을 보장해야 하므로  
통신간 데이터가 정상적으로 송/수신이 이루어졌는지 확인하는 과정이 필요하며, 이 과정의 근간이 되는 개념이 3-way Handshaking이다.
<br>

### 3-way Handshaking 
<img src="https://www.mdpi.com/applsci/applsci-06-00358/article_deploy/html/images/applsci-06-00358-g001-550.jpg"><br>
seq: 송신측에서 보내는 데이터 세그먼트의 일련번호
ack: 상대편 노드에 전송하기를 요청하는 다음 세그먼트의 일련번호

### 연결 설정시의 3-way Handshaking 과정
1. 클라이언트에서 초기 순서 번호를 선택한 첫 번째 세그먼트인 SYN 세그먼트를 SYN 플래그를 1로 하여 전송한다.
2. 서버측에서 두 번째 세그먼트로써 SYN과 ACK 플래그 비트가 1로 설정된 세그먼트를 전송한다.  
이 세그먼트를 통해 서버에서 통신이 개시했음을 알림과 동시에 이전에 클라이언트에서 요청한 통신 개시에 대한 요청을 수락했음을 알린다.
3. 클라이언트 측에서 ACK 플래그만 1로 설정된 세그먼트를 송신한다. 이를 통해 서버측에서 보낸 통신 개시 선언 세그먼트가 잘 수신되었음을 알려주고, 클라이언트측 통신도 개시(Establish)상태로 변경한다.
<br/>

### 데이터 송·수신시의 3-way Handshaking 과정
1. 송신측에서 ACK, PSH 플래그가 1로 설정된 TCP 헤더와 일정 바이트수만큼 데이터를 보낸다.
2. 수신측에서 ACK, PSH 플래그가 1인 TCP 헤더와 데이터를 전송하고 데이터와 확인응답을 동시에 처리한다.
3. 송신측에서 1번과 동일한 방법으로 데이터를 전송한다. 만약 전송할 데이터가 없으면 ACK 플래그가 1로 설정된 TCP 헤더만 전송한다.
<br/>

### 연결 해제시의 3-way Handshaking 과정
- 연결 설정시의 3-way Handshaking 과정과 거의 동일하다. 단, SYN 플래그가 아닌 FIN 플래그가 1로 설정된 상태인 것만 다르다.
<br><br>

## 흐름 제어
데이터 처리 속도를 조절하거나 한정된 버퍼 상태로 인해 데이터의 손실(오버플로우)가 발생하지 않도록 상대 측에 알림으로써  
데이터 간의 세그먼트 양을 제어하기 위해 사용하는 기법이다.

<br/>

### 슬라이딩 윈도우 프로토콜
TCP에서 흐름제어를 위해 가장 많이 사용하는 방식으로, 상위 계층 프로세스로부터 전달된 데이터를 저장하는 버퍼 중 일부분을 가리킨다.  
윈도우 내의 바이트는 확인응답을 수신하지 않고도 연속해서 전송될 수 있고, start 지점과 end 지점이 데이터 배열을 미끄러지듯이 이동한다.  
<br/><br/>

## 오류 제어
- 세그먼트 내 오류 발생 여부 확인 : 검사합 (Checksum)
- 데이터 세그먼트의 손실 발생 여부 확인 : SEQ, ACK의 데이터 패킷 번호를 통해 확인
<br><br><br>




# UDP
- TCP의 복잡한 제어를 제거하고 속도, 실시간성이 요구되는 통신의 필요조건을 만족시킨 통신 방식.
- 흐름 제어가 없고 수신된 패킷에 대한 확인응답도 없음.
- 수신 패킷에 오류는 발견할 수 있지만, 대부분의 경우 패킷을 폐기처분하는것으로 오류를 처리함.
- 데이터 단위: 데이터그램
<br><br>

### UDP에서 잘 알려진 포트 번호
|포트 번호|응용 프로토콜|설명|
|:---:|:---:|:---|
|7|Echo|수신된 메시지를 송신 측에 에코함|
|9|Discard|수신된 메시지를 버림|
|11|Users|활성화된 사용자|
|13|Daytime|현재 날짜와 시간을 반환|
|69|TFTP|파일 전송 프로토콜|
|111|RPC|원격 제어를 위한 프로세스간 통신|
|123|NTP|하드웨어 디바이스간 시간 동기화|
|161|SNMP|간이 망 구성 관리 프로토콜 (에이전트)|
|162|SNMP|간이 망 구성 관리 프로토콜 (호스트)|
<br><br>

## UDP 헤더
<img src="https://3827551924-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M26jG1uJ-xuMP0XPOri%2Fsync%2F0438be2b246e5f9324ccd184b7cd152686b08a24.png?generation=1626009659727407&alt=media"><br/>
[UDP 헤더의 구조]  
- 발신지 포트 주소 : 발신측이 클라이언트라면 임의로 지정된 포트번호가, 서버라면 잘 알려진 포트번호가 기록되어있다.
- 목적지 포트 주소 : 수신측이 서버라면 잘 알려진 포트번호를 기록하고, 클라이언트라면 직전에 수신된 패킷의 발신 포트번호를 복사해온다.
- 길이: 헤더와 데이터를 합한 사용자의 데이터그램의 전체 길이를 나타낸다. 이 필드가 없다 하더라도 IP 데이터그램에서 IP 헤더의 길이를 뺌으로써 사용자의 UDP 데이터그램의 길이를 알 수 있다.
- 검사합: 헤더와 데이터를 모두 포함한 사용자 데이터그램 전체에 대해 오류를 탐지하기 위해 사용되는 영역이다.
<br><br>

## UDP 통신
UDP는 비연결형 서비스이므로 통신간 데이터가 정상적으로 송수신 되었는지 여부를 확인할 필요가 없다.  
또, UDP를 통해 보내진 데이터들은 데이터의 순서가 없기 때문에 각각이 독립적인 데이터 덩어리라고 할 수 있다.  
<br>
UDP는 이와 같은 특성 때문에 흐름 제어가 없고, 오류 발생 시에도 별다른 처리 매커니즘이 없다.  
검사합(checksum)을 통해 오류의 발생 여부는 검출이 가능하지만, 오류가 발생한 데이터는 대부분 버려진다.  
<br><br>

## 캡슐화, 역캡슐화
한 프로세스에서 다른 프로세스로 메시지를 보낼 때, UDP는 아래 이미지와 같은 방식으로 데이터그램을 캡슐화/역캡슐화 한다.  
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbKckzm%2FbtqElkMkJcg%2Fz1zHI2ZMvwmP7r5gtOkOxk%2Fimg.png" width=700>
<br><br>

## 큐잉
UDP 또한 데이터를 주고받을 때 프로세스를 식별하는 방식으로 포트번호를 사용한다.  
이 때, 데이터의 순서가 없는 통신방식의 특성 상 데이터를 들어오는 순서대로 처리하게 되는데,  
FIFO의 개념이 도입된 큐의 방식을 사용한다.  
<br>
각 포트별로 입력과 출력 하나씩, 총 2개의 큐가 배정된다.  
만약 큐가 가득찬 경우 OS에서 대기 신호를 발생시키고,  
포트가 죽은 포트(포트에 대응되는 프로세스가 없는 경우)라면 포트 도착 불가 신호를 보낸다.  
<br>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcazatx%2FbtqEj9LwyjB%2Fn1KJ8IMkwFkkez6OYUikt0%2Fimg.png" width=700>  
<br><br>

## MUX, DeMux
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FclPwZQ%2FbtqEj9SnFFL%2FzND4kUoj21c40QAgrsKOi0%2Fimg.png" width=700>  

UDP를 사용하는 여러 응용프로그램의 출력이 UDP의 MUX에서 멀티플렉싱되어 하나의 데이터그램으로 취급되어 송신된다.  
MUX에서는 송신자의 포트번호를 제어 신호로 사용한다.  
DeMUX에서는 목적지 포트 번호를 확인하여 해당 포트번호에 대응되는 프로세스에게 메시지를 전달한다.
<br><br><br>

# 문제
1. TCP는 포트번호를 이용하여 프로세스 간 통신을 수행한다.  
이 과정에서 서버측와 클라이언트측의 포트번호 할당 방식이 다른데,  
①[<u>**클라이언트 측에서의 포트번호 할당 방식**</u>]과, ②[<u>**할당될 수 있는 포트번호의 유효범위와 정확히 일치하는 JAVA의 자료형**</u>]은 무엇인지 답하시오.  
(포트번호의 예약 여부 및 사용되고 있는지 여부는 고려하지 않는다고 가정한다.)
<br>

2. UDP에서 ①[<u>**데이터의 오류를 검출하는 방식이 있는지 여부(O, X)**</u>]를 말하고,   
   ②[<u>**만약 있다고 답한 경우 어떤 기법을 통해 오류를 검출하는지, 또 오류가 발생한 데이터는 어떤 방식으로 처리하는지**</u>] 설명하시오.